function Method_of_Dividing_a_Segment_in_half
arr=[];
a=0.2;
b=1;
eps=10e-4; 
x=(a+b)/2; % Вычисляем среднюю точку сегмента
f_x=f(x); % Вычисляем значение функции в средней точке сегмента
arr=[arr x]; % Добавляем точку в массив

while b-a > eps % Условие выхода (Пока длина сегмента локализации меньше требуемой точности)
    x_1 = a + (b - a)/4; % Вычисляем потенциально новые концы сегмента
    x_2 = b - (b - a)/4;
    f_x_1=f(x_1); % Вычисляем значения функции в потенциально новых концах сегмента
    f_x_2=f(x_1); 
    if f_x_1 < f_x % Определяем концы нового сегмента локализации
        b = x;
        x = x_1;
    else
        if f_x_2 < f_x
            a = x;
            x = x_2;
        else
            a = x_1;
            b = x_2;
        end
    end
    disp(x);
    arr=[arr x];
end
f_x_min = f(x);
disp('Точка минимума =');
disp(x);
disp('Значение в точке минимума =');
disp(f_x_min);
disp(arr);
x_0=0.2 : 0.01 : 1;
f_x_0=f(x_0);
plot(x_0,f_x_0,'b'); % Вывод график минимизируемой функции
hold on;
f_x_arr=f(arr);
plot(arr,f_x_arr,'ro'); % Вывод точек на оси абсцисс, являющихся последовательными приближениями в методе деления пополам
end


function f=f(x)
  % Заданная функция
  f=x.*sin(1./x);
end
